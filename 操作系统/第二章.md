# 第二章 进程的描述与控制
## 2.1 前驱图和程序执行
### 2.1.1 前驱图
定义：有向无循环图（DAG），是一个二元组，由结点的集合和有向边组成。  
结点：表示一个进程、程序段或语句  
有向边：两个结点之间的前驱关系，也叫偏序关系，记为'->'。  
若P<sub>i</sub>和P<sub>j</sub>存在前驱关系，则记作P<sub>i</sub>->P<sub>j</sub>，表示P<sub>i</sub>必须在P<sub>j</sub>执行前完成。同时P<sub>i</sub>是P<sub>j</sub>的直接前驱，P<sub>j</sub>和P<sub>i</sub>的直接后继。  
没有前驱的结点称为初始结点。  
没有后继的结点称为终止结点。  
### 2.1.2 程序顺序执行
通常一个程序可分成若干个程序段，它们必须按照某种先后次序执行，仅当前一操作执行后，才能执行后继操作。

程序顺序执行时有如下特征：  
* 顺序性：处理机的操作严格按照程序所规定的顺序执行，每一操作必须在下一个操作开始之前结束。  
* 封闭性：在封闭环境下执行，独占全机资源，执行结果不受外界影响。
* 可再现性：只要程序执行时的环境和初始条件相同，当程序重复执行时，不论它是从头到尾不停顿地执行，还是“走走停停”地执行，都将获得相同的结果。

### 2.1.3 程序并发执行
程序并发执行时的特征：
* 间断性：相互制约导致并发程序具有“执行-暂停-执行”这种间断性的活动规律。
* 失去封闭性：多个程序共享系统中的各种资源，资源状态由多个程序来改变。
* 不可再现性：由于程序的并发执行，打破了由一个程序独占系统资源的封闭性，因而破坏了可再现性。  

程序并发执行的条件（Bernstein条件)：  
读集 R(p<sub>i</sub>)={a1,a2,a3,…,am}：  
表示程序pi在执行期间所需参考的所有变量的集合。  
写集 W(p<sub>i</sub>)={b1,b2,b3,…,bm}：  
表示程序pi在执行期间要改变的所有变量的集合。  
若两个程序p1和p2能满足下述条件，它们便能并发执行，且具有可再现性。  
R(p1)$\bigcap$W(p2)$\bigcup$R(p2)$\bigcap$W(p1)$\bigcup$W(p1)$\bigcap$W(p2)={}

## 2.2 进程的描述
### 2.2.1 进程的定义和特征  

进程(process)的定义：  
1）进程是程序的一次执行。  
2）进程是一个程序及其数据在处理机上顺序执行时所发生的活动。  
3）进程是程序在一个数据集合上的运行过程，它是系统进行资源分配和调度的一个独立单位。  
传统os中的进程定义为：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。  
进程实体由程序段、相关的数据段和PCB三部分构成。  

进程和程序的主要区别：  
* 程序是指令的有序集合，其本身没有任何运行的含义，它是一个**静态**的概念。而进程是程序在处理机上的一次执行过程，它是一个**动态**概念。
* 程序的**存在是永久**的。而**进程则是有生命期**的，**它因创建而产生，因调度而执行，因得不到资源而暂停执行，因撤消而消亡。**
* 程序仅是**指令的有序集合**。而进程则由**程序段**、**相关数据段**、 **进程控制块（PCB）** 组成。
* **进程与程序之间不是一一对应**。一个程序可对应多个进程、一个进程可包含多个程序（至少包含一个程序）  
* 程序存储在外存、进程存储在内存。

进程的特征：
1. 结构特征：由程序段、相关数据段及进程控制块（PCB）组成。
2. 动态性：进程的实质是进程实体的一次执行过程，因此是动态的。所以动态性是进程的最基本的特征。同时动态性还表现在进程是有生命期的，它因创建而产生，因调度而执行，因得不到资源而暂停执行，因撤消而消亡。  
3. 并发性：指多个进程实体同时存在于内存中，能在一段时间内同时运行。引入进程的目的就是为了使进程能并发执行，以提高资源利用率，所以并发性是进程的重要特征，也是OS的重要特征。
4. 独立性：指进程是一个能独立运行的基本单位，也是系统进行资源分配和调度的独立单位。
5. 异步性：指进程以各自独立的、不可预知的速度向前推进。

### 2.2.2 进程的基本状态及转换
为了刻画了整个进程，可以将一个进程的生命周期划分为一组状态：
两种短暂的状态、三种基本状态。  
* new新建/创建:进程正在创建中的状态
* terminated终止/撤消/退出：进程执行完毕，释放所占资源的状态。
* ready-就绪: 进程已获得了除处理机以外的所有资源，等待分配处理机执行的状态。
* running-运行/执行: 当一个进程获得必要的资源并正在处理机上执行的状态。
* waiting-等待/阻塞: 正在执行的进程由于发生某事件而暂时无法执行下去，此时进程所处的状态。

#### 基本状态的转换：
* 执行->阻塞：I/O请求
* 阻塞->就绪：I/O完成
* 就绪->执行：进程调度
* 执行->就绪：处理器时间结束
* 创建->就绪
* 执行->终止


### 挂起操作和进程状态的转换
* 在某些系统中，为了更好地管理和调度进程，引入了挂起状态
* 挂起状态/静止状态：程序在运行期间，由于某种需要，往往要将进程暂停执行，使其静止下来，以满足某些需要。这种静止状态就称为进程的挂起状态。
* 挂起原语Suspend和激活原语Active
* 引入的原因：
  * 终端用户的需要：终端用户在自己程序运行中发现问题要求使正在执行的进程暂停执行而使进程处于挂起状态。
  * 父进程的需要：父进程为了考查和修改某个子进程，或者协调各子进程间的活动，需要将该子进程挂起。
  * 操作系统的需要：操作系统为了检查运行中的资源使用情况或进行记帐，而将某些进程挂起。
  * 对换的需要：为了提高内存的利用率，将内存中某些进程挂起，以调进其它程序运行。
  * 负荷调节的需要：由于工作负荷较重，而将一些不重要的进程挂起，以保证系统能正常运行（实时操作系统）
* 引入挂起后的状态转换
  * 创建->活动就绪
  * 创建->静止就绪
  * 活动就绪->静止就绪
  * 活动阻塞->静止阻塞
  * 静止就绪->活动就绪
  * 静止阻塞->活动阻塞
### 进程管理中的数据结构
* 内存表、设备表、文件表、进程表（PCB）
#### 进程控制块 Process Control Block
* PCB是操作系统为了管理和控制进程的运行而为每一个进程定义的一个记录型数据结构，它记录了系统管理进程所需的全部信息。系统根据PCB而感知进程的存在，PCB是进程存在的唯一标志。
* 作用：
  * 作为独立运行基本单位的标志：系统是通过PCB感知进程的存在的，PCB是进程存在的唯一标志。
  * 能实现间断性运行方式：当进程因阻塞暂停运行时，CPU的现场信息保存在该进程的PCB中
  * 提供进程管理所需要的信息
  * 提供进程调度所需要的信息
  * 实现与其他进程的同步和通信
* PCB中的信息：
  * 进程标志符：两种
    * 外部标识符：由字母、数字组成，由用户访问该进程时使用
    * 内部标识符：由系统创建进程时分配给进程的唯一标识号，通常为一整数，称为进程号，用于区分不同的进程。
  * 处理机状态（断点信息）：即处理机中各种寄存器（通用寄存器、PC、PSW等）的内容
  * 进程调度信息：记录了进程调度的相关信息（状态、优先级、事件等）。
  * 进程控制信息：记录了系统对进程控制的信息（程序和数据的地址、同步机制、资源清单、链接指针）
* PCB的组织方式：
  * 线性：线性表
  * 链式：把同一状态的PCB链接成一个队列，这样就形成了就绪队列、阻塞队列等。
  * 索引：将同一状态的进程组织在一个索引表中，索引表的表项指向相应的PCB，不同状态对应不同的索引表。
### 进程控制
#### 操作系统内核
* 在现代OS中，常把一些功能模块（与硬件紧密相关的、常用设备的驱动程序及运行频率较高的）放在紧靠硬件的软件层次中，加以特殊保护，同时把它们常驻内存，以提高OS的运行效率，这部分功能模块就称OS的内核。
* 内核是基于硬件的第一层软件扩充，它为系统控制和管理进程提供了良好的环境
* 最核心功能的集合
* 主要功能：
  * 支撑功能：中断处理、时钟管理、原语操作
  * 进程管理：创建和终止、调度和分派、进程切换、同步和通信、对PCB的管理
  * 存储器管理：内存分配和回收、内存保护和交换、分页和分段管理
  * 设备管理：缓冲区管理、I/O设备的分配、设备驱动、设备独立性功能模块
* 处理机的执行状态：  
  
| 处理机状态  | 特权(执行指令,访问） | 程序 |
| ------ | ------ | ------ |
| 系统态(核心态、管态) | 较高(一切指令,所有寄存器及存储区)|OS内核|
| 用户态（目态） | 较低(规定指令,指定寄存器及存储区) | 用户程序或系统外层的应用程序 |

#### 进程创建
* 一个进程可以创建若干个新进程，新创建的进程又可以创建子进程，为了描述进程之间的创建关系，引入了进程图。
* 创建进程的进程称为父进程，被创建的进程称为子进程。
* 进程图：又称为进程树或进程家族树，是描述进程家族关系的一棵有向树。
* 引起进程创建的事件：
  * 系统初始化：启动操作系统时，会创建若干进程，包括一些前台进程和后台进程（具有专门的功能，如接收发来的邮件、接收Web请求等）
  * 用户登录：在分时OS中，用户在终端键入登录命令后，如是合法用户，则系统为该终端创建一进程，并插入就绪队列
  * 作业调度：在批处理OS中，当按某算法调度一作业进内存，系统为之分配必要资源，同时为该作业创建一进程，并插入就绪队列。
  * 提供服务：在程序运行中，若用户需某种服务，则系统创建一进程为用户提供服务，并插入就绪队列。
  * 应用请求：在运行中，由于应用进程本身的需求，自己创建一进程，并插入就绪队列
* 进程创建：
  * 操作系统一旦发现了要求创建进程的事件后，便调用进程创建原语create()按以下过程创建一新进程：
    * 申请空白PCB
    * 为新进程分配资源
    * 初始化PCB
    * 将PCB插入就绪队列
    * 返回进程标识号
#### 进程撤销
* 导致进程撤销的事件
  * 进程正常结束：执行一个OS调用表示进程运行完毕
  * 进程异常结束：如运行超时、内存不足、越界错误、保护错误、算术错误、等待超时、I/O故障、非法指令、特权指令错等。
  * 外界干预：
    * 操作员或操作系统干预；
    * 父进程终止；
    * 父进程请求（父进程拥有终止所有子孙进程的权限）
* 撤消原语可采用2种撤消策略：
  * 只撤消指定的进程（指定进程撤消后，会将其子孙进程交给系统进程管理）
  * 撤消指定进程及其所有的子孙进程
* 进程撤消的过程：如果系统中发生了要求撤消进程的事件，OS便调用撤消原语去撤消进程：
  * 由标识符在PCB集中找PCB并读取状态
  * 若被撤销进程处于执行状态，则终止进程的执行
  * 若该进程还有子孙进程，将所有子孙进程终止
  * 归还资源
  * PCB从所在队列移除
#### 进程的阻塞与唤醒
* 当一个进程期待的事件还没有出现时，该进程调用阻塞原语block()将自己阻塞起来
* block()功能：将进程由执行状态转变为阻塞状态。
* 对于处于阻塞状态的进程，当该进程期待的事件出现时，由其它相关进程调用唤醒原语wakeup() 将阻塞的进程唤醒，使其进入就绪状态；
* wakeup()功能：将进程由阻塞状态转变为就绪状态。
* 引起进程阻塞和唤醒的事件：
  * 请求系统服务
  * 启动某种操作
  * 新数据尚未到达
  * 无新工作可做
* 进程阻塞过程：
  * 停止执行
  * 修改PCB状态
  * 插入到相应队列
  * 重新调度
* 进程的唤醒过程：
  * 移出阻塞队列
  * 修改PCB状态
  * 插入到就绪队列
  * 重新调度
#### 进程挂起与激活
* 当引起进程挂起的事件发生时，系统就将利用挂起原语suspend()将指定进程或处于阻塞状态的进程挂起。
* 当发生激活进程的事件时，系统就将利用激活原语active()将指定进程激活。
* 进程的挂起过程：
  * 检查状态
  * 修改状态
  * 复制PCB至指定内存
  * 重新调度
* 进程的激活过程
  * 将进程从外存调入内存
  * 修改PCB状态
  * 检查是否重新调度
### 进程同步
* 为了使多道程序系统中，多个进程能够正确地运行，必须引入同步机制
#### 基本概念
* 进程同步：指对多个相关进程在执行次序上进行协调
* 任务：使系统中各进程之间能有效地共享资源和相互合作，从而使程序的执行具有可再现性
* 系统中各进程之间在逻辑上的相互制约的关系：
  * 直接相互制约关系/相互合作关系（进程同步）：即为完成同一个任务的各进程之间，因需要协调它们的工作而相互等待、相互交换信息所产生的直接制约关系。
  * 间接相互制约关系/资源共享关系（进程互斥）：是进程共享独占型资源而必须互斥执行的间接制约关系。只能由系统分配。
  * 在多道程序环境下，由于相互制约关系，进程在运行过程中是否能获得 处理机运行和以怎样的速度运行，并不能由进程自身所控制，这是进程的异步性。
  
  | 同 步（直接制约）| 互 斥（间接制约) |
  | ----| ---|
  |进程-进程|进程-资源-进程|
  |时间次序上受到某种限制|竞争不到某一物理资源时不允许进程工作|
  |相互清楚对方的存在及作用，交换信息|不一定清楚其它进程的情况|
  |往往指有几个进程共同完成一个任务|往往指多个任务多个进程间通讯制约|

* 临界资源：一次只允许一个进程使用的共享资源称为临界资源。各进程间采取互斥方式实现对这种临界资源的共享，从而实现并发进程的封闭性。
* 临界区：每个进程中访问临界资源的代码
* 进入区：增加在临界区前面的一段代码，用于检查所要访问的临界资源此刻是否被访问。
* 退出区：增加在临界区后面的一段代码，用于将临界资源的访问标志恢复为未被访问标志。
* 剩余区：进程中除了进入区、临界区及退出区之外的其余代码。
* 要进入临界区的若干进程必须满足：
  * 一次只允许一个进程进入临界区
  * 任何时候，处于临界区的进程不得多于一个
  * 进入临界区的进程要在有限的时间内退出
  * 如果不能进入自己的临界区，则应让出处理机资源、
* 同步机制应遵循的规则：
  * 空闲让进
  * 忙则等待
  * 有限等待
  * 让权等待

#### 信号量机制
* 信号量机制是荷兰科学家E.W.Dijkstra在1965年提出的一种同步机制，也称为P、V操作。
* 整型信号量：非负整数，除了初始化（即赋初值：必须置一次且只能置一次初值，初值不能为负数）外，只能通过两个原子操作wait和signal（或者叫P、V操作）来访问（即信号量的值仅能由这两个原子操作来改变 ）。
* 主要问题：只要S $\leq$ 0， wait操作就不断地测试（忙等），因而，未做到“让权等待”。
* 记录型信号量：
  * 设置一个代表资源数目的整型变量value（资源信号量）
  * 设置一链表L用于链接所有等待访问同一资源的等待进程
* S.value的初值表示系统中某类资源的数目。
  * S.value的初值为1，S为互斥信号量；
  * S.value的初值大于1，S为资源信号量；
  * S.value的初值为0：用来描述进程之间的前趋关系
* 具体操作：
  * 每次wait(S)操作意味着进程请求一个单位的资源，资源数目减1。当S.value<0时表示资源已分配完毕，进程调用Block()原语进行自我阻塞，放弃处理机，并插入到信号量链表S.L中。此时，|S.value| 表示在该信号量链表中已阻塞进程的数目。
  * 每次signal(S)表示执行进程释放一个单位资源，资源数目加1。若加1后仍有S.value<=0，则表示在该信号量链表中，还有等待该资源的进程，则调用Wakeup()原语，将链表中第一个进程唤醒。
* AND信号量：  
  将进程在整个运行过程中所需要的所有临界资源，一次性全部分配给进程，待进程使用完后再一起释放。只要有一个资源未能分配给进程，其它所有可能分配的资源也不分配给该进程。从而可避免死锁发生。在wait操作中，增加了一个“AND”条件，故称为AND同步。
* 一般信号量集：  
  一次可分配多个某类临界资源，而不需执行N次的P操作；每次分配前都测试该类资源数目是否大于测试值。
  Swait(S1,t1,d1;S2,t2,d2;...;Sn,tn,dn), Si为信号量，di为需求值，ti为下限值（测试值）
  * 一般信号量集的几种特殊情况：
    * Swait(S,d,d)：信号量集中只有一个信号量，但允许它每次申请d个资源，当资源数少于d时，不予分配。
    * Swait(S,1,1)：蜕化为一般的记录型信号量（S>1时）或互斥信号量（S=1时）。
    * Swait(S,1,0)：很有用的信号量操作，相当于一个可控开关，当S>=1时，开（允许多个进程进入）；当S=0时，关（阻止任何进程进入）。
### 信号量的应用
* 利用信号量实现进程互斥：为临界资源设置一互斥信号量lock，初值为1
* 利用信号量描述前趋关系  
  进程P1的语句序列为：S1;V(s)  
  进程P2的语句序列为：P(s);S2  
  则S1->S2

### 管程机制
* 信号量机制实现进程同步的问题：
  * 每个访问临界资源的进程都必须自备同步操作（P、V操作），这使大量的同步操作分散在各个进程中，给系统的管理带来麻烦。
  * 会因同步操作使用不当而导致系统死锁。
* 基本思想：  
    系统中的各种软硬件资源，其特性都可用数据结构抽象地描述，把对该共享数据结构实施的操作定义为一组过程。  
    进程对共享资源的访问都是通过这组过程对共享数据结构的操作来实现的，这组过程可以根据资源的使用情况，接受或阻塞进程的访问，确保每次只有一个进程使用共享资源，实现进程的互斥。
* 管程的定义：一个数据结构和在该数据结构上能被并发进程所执行的一组操作，这组操作能同步进程和改变管程中的数据。
* 管程的组成：
  * 管程的名称
  * 局部于管程内部的共享数据结构说明
  * 对该数据结构进行操作的一组过程
  * 对局部于管程内部的共享数据设置初始值的语句
* 局部于管程内部的数据结构，只能被局部于管程内部的过程所访问；反之，局部于管程内部的过程也只能访问管程内的数据结构。
* 管程的特性：
  * 模块化：是一个基本程序单位，可单独编译。
  * 抽象数据类型：管程中不仅有数据，而且有对数据的操作。
  * 信息隐蔽：数据结构和过程的具体实现外部不可见
* 管程与进程的区别：
  * 进程定义私有数据结构PCB，管程定义公共数据结构。
  * 进程由顺序程序执行相关操作，管程主要进行同步操作和初始化操作
  * 进程用于实现系统并发性，管程用于解决共享资源的互斥问题
  * 进程调用管程中的过程对共享数据结构实行操作，为被动方式；进程为主动方式
  * 进程间为并发执行，管程是操作系统中的一个资源管理模块
* 条件变量：
  * 条件变量是一种抽象数据类型，保存了一个链表，用于记录因该条件变量而阻塞的所有进程
  * 仅可进行P、V操作
## 经典进程的同步问题
### 生产者-消费者问题
* 问题描述：它描述了一组生产者向一组消费者提供产品，它们共享一个缓冲池（有n个缓冲区），生产者向其中投放产品，消费者从中取得产品。
* 对于一个生产者，一个消费者，公用一个缓冲区：
  * 定义两个同步信号量：
    * empty——表示缓冲区是否为空，初值为1。
    * full——表示缓冲区中是否为满，初值为0。
* 对于M个生产者，K个消费者，公用有n个缓冲区的缓冲池：
  * 设置两个同步信号量及一个互斥信号量：
    * empty：说明空缓冲区的数目，其初值为缓冲池的大小n，表示消费者已把缓冲池中全部产品取走，有n个空缓冲区可用。
    * full：说明满缓冲区的数目（即产品数目），其初值为0,表示生产者尚未把产品放入缓冲池，有0个满缓冲区可用。
    * mutex: 说明该缓冲池是一临界资源，必须互斥使用，其初值为1。
* 注意点：
  * 互斥信号量的P、V操作在每一进程中必须成对出现。
  * 对资源信号量(full,empty)的P、V操作也必须成对出现，但可分别处于不同的进程中。
  *  多个P操作顺序不能颠倒。
  *  先执行资源信号量的P操作，再执行互斥信号量的P操作，否则可能引起进程死锁。
  * 它是一个同步问题：
      * 消费者想要取产品，缓冲池中至少有一个缓冲区是满的。
      * 生产者想要放产品，缓冲池中至少有一个缓冲区是空的。
  * 它是一互斥问题：缓冲池是临界资源，因此，各生产者进程和各消费者进程必须互斥访问。
* 使用管程解决：
  ```
  Type PC = monitor
  var in, out, count: integer;
  buffer: arrar[0, ..., n - 1] of item;
  notfull, notempty: condition;
  put(item);
  get(item);

  begin
    in:= out:= 0;
    count:=0;
  end
  ```
  * put(item)过程:  生产者利用此过程将自己生产的产品放到缓冲池中，若发现缓冲池已满（count n)，则等待。
  ```
  Procedure entry put(item)
    begin
      if count >= n then
        notfull.wait;
      buffer[in] := nextp;
      in := (in + 1) mod n;
      count := count + 1;
      if notempty.queue then
        notempty.signal;
    end
  ```
  * get(item)过程:消费者利用此过程将缓冲池中的产品取走，若发现缓冲池已空（count 0)，则等待。
  ```
  Procdeure entry get(item)
    begin
      if count = 0 then
        notempty.wait;
      nxetc := buffer[out];
      out := (out + 1) mod m;
      count := count - 1;
      if notfull.queue then
        notfull.signal;
    end
  ```
  ```
  Producer: 
    begin
      repeat
        produce an item in nextp;
        PC.put(item);
      until flase
    end
  
  Consumer:
    begin
      repeat
        PC.get(item);
        consume the item in nextc;
      until false
    end
  ```
### 哲学家进餐问题
* 描述：有五个哲学家，他们的生活方式是交替地进行思考和进餐。他们共用一张圆桌，分别坐在五张椅子上。在圆桌上有五个碗和五支筷子，平时一个哲学家进行思考，饥饿时便试图取用其左、右最靠近他的筷子，只有在他拿到两支筷子时才能进餐。进餐毕，放下筷子又继续思考。
* 哲学家进餐问题可看作是并发进程并发执行时，处理共享资源的一个有代表性的问题。
* 利用记录型信号量解决哲学家进餐问题。
    * 考虑每个筷子作为临界资源，进餐时，优先选择左边的筷子，之后在执行右边的筷子。
  * 问题：产生死锁。 
  * 解决方法：
    1. 限制人数最多4人
    2. 设置为AND信号量
    3. 规定奇数先用左边，偶数先用右边。
### 读者-写者问题
* 描述；数据文件或记录文件可被多个进程共享，我们把只要求读该文件的进程称为Reader进程，其他称为 Writer进程。允许多个进程同时读一个共享对象，但不允许一个Writer进程与其他的Reader进程或者Writer进程同时访问共享对象。
* 记录型信号量解法：
  * 设置一个共享变量和两个信号量：
    * 共享变量readcount：记录当前正在读数据集的读进程数目，初值为0。
    * 读互斥信号量rmutex ：表示读进程互斥地访问共享变量readcount，初值为1.
    * 写互斥信号量wmutex：表示写进程与其它进程（读、写）互斥地访问数据集，初值为1.
  * 仅当readcount=0，才执行wait（wmutex）
  * 仅当readcount=1，才执行siganl（wmutex）
  

 


